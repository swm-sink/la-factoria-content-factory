# Docker Compose configuration for local development.
# This file defines services, networks, and volumes for running the application
# locally using Docker. It aims to replicate the production container environment
# as closely as possible for development and testing.

services:
  app: # Renamed from 'backend' to 'app' to reflect it runs the combined image
    build:
      context: .
      dockerfile: Dockerfile # This now refers to the multi-stage root Dockerfile
    ports:
      # Port 80 on the host maps to port 80 in the container (where Nginx listens).
      # Nginx serves the frontend and proxies /api to Uvicorn.
      - "80:80"
      # Optionally, expose Uvicorn's direct port if needed for direct backend access during dev.
      # APP_PORT (default 8000) is Uvicorn's internal port, proxied by Nginx.
      # If direct access to Uvicorn on 8000 is needed:
      # - "8000:8000"
    env_file:
      - .env # Load environment variables from root .env file
    volumes:
      # Mount the backend app code for live reloading during development.
      # Note: Frontend changes require a rebuild of the image if served by Nginx from build artifacts.
      # For live frontend development, run 'npm run dev' in the frontend directory separately.
      - ./app:/opt/app_code/app
      # Optionally mount nginx config for local overrides if needed:
      # - ./docker/nginx/nginx.conf:/etc/nginx/nginx.conf:ro
    command: /start.sh # Use the same startup script as the Dockerfile CMD

  # frontend: # Commented out as frontend is served by Nginx within the 'app' service.
    # For dedicated live frontend development, run 'npm run dev' in the 'frontend' directory.
    # build:
    #   context: ./frontend
    #   dockerfile: Dockerfile
    # ports:
    #   - "5173:5173"
    # volumes:
    #   - ./frontend/src:/app/src
    # command: npm run dev

volumes:
  postgres_data: # Example if you add a database service
