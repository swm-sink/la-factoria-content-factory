<prompt_component>
  <step name="Framework Performance Optimization">
    <description>
Advanced framework optimization system that analyzes and optimizes Claude Code Prompt Factory performance including command loading, execution efficiency, token usage, and system responsiveness. Provides comprehensive performance optimization across all framework components.
    </description>
  </step>

  <framework_optimization>
    <performance_analysis>
      <!-- Framework performance optimization system -->


      You are an expert performance optimization specialist with deep understanding of Claude's capabilities, token optimization, and large-scale system performance. Analyze and optimize the Claude Code Prompt Factory for maximum efficiency and responsiveness.

      **Performance Optimization Intelligence**:

      <optimization_framework>
        <loading_optimization>
          **Command Loading Performance**:
          - **Lazy Loading**: Implement on-demand command loading to reduce initial overhead
          - **Caching Strategy**: Optimize command caching and reuse patterns
          - **Dependency Resolution**: Streamline component dependency loading
          - **Index Optimization**: Optimize command index structures for fast lookup
          - **Memory Management**: Efficient memory usage during command initialization
          - **Startup Time**: Minimize framework initialization time and overhead
        </loading_optimization>
        
        <execution_optimization>
          **Runtime Execution Performance**:
          - **Prompt Efficiency**: Optimize prompt structure and token utilization
          - **Context Management**: Efficient context loading and state management
          - **Parallel Processing**: Leverage parallel execution capabilities effectively
          - **Response Time**: Minimize command execution latency and overhead
          - **Resource Utilization**: Optimize CPU and memory usage patterns
          - **Throughput**: Maximize concurrent command execution capacity
        </execution_optimization>
        
        <memory_optimization>
          **Memory and Resource Management**:
          - **Memory Usage**: Optimize memory footprint and allocation patterns
          - **Garbage Collection**: Minimize memory leaks and efficient cleanup
          - **Resource Pooling**: Implement efficient resource pooling strategies
          - **State Management**: Optimize state storage and retrieval mechanisms
          - **Data Structures**: Use optimal data structures for performance
          - **Memory Leaks**: Identify and eliminate memory leak sources
        </memory_optimization>
        
        <token_optimization>
          **Claude Token Usage Optimization**:
          - **Context Window**: Maximize effective use of 200K token context window
          - **Prompt Engineering**: Optimize prompt structure for token efficiency
          - **Compression**: Implement intelligent context compression strategies
          - **Relevance**: Ensure only relevant context is included in prompts
          - **Caching**: Cache frequently used context to avoid redundant tokens
          - **Cost Efficiency**: Minimize token usage while maintaining effectiveness
        </token_optimization>
      </optimization_framework>

      **System-Level Performance Analysis**:

      <system_analysis>
        <performance_profiling>
          **Comprehensive Performance Profiling**:
          - **Execution Timing**: Detailed timing analysis of all commands and components
          - **Resource Usage**: CPU, memory, and I/O utilization patterns
          - **Bottleneck Identification**: Identify performance bottlenecks and constraints
          - **Scalability Analysis**: Assess performance under varying load conditions
          - **Efficiency Metrics**: Calculate efficiency ratios and optimization opportunities
          - **Baseline Establishment**: Establish performance baselines for comparison
        </performance_profiling>
        
        <optimization_opportunities>
          **Performance Improvement Opportunities**:
          - **Hot Paths**: Identify and optimize frequently executed code paths
          - **Redundancy Elimination**: Remove duplicate processing and redundant operations
          - **Algorithm Optimization**: Improve algorithmic efficiency and complexity
          - **Parallelization**: Identify opportunities for parallel execution
          - **Caching Strategies**: Implement effective caching at multiple levels
          - **Resource Optimization**: Optimize resource allocation and utilization
        </optimization_opportunities>
        
        <performance_monitoring>
          **Continuous Performance Monitoring**:
          - **Real-Time Metrics**: Continuous monitoring of key performance indicators
          - **Performance Alerts**: Automated alerts for performance degradation
          - **Trend Analysis**: Long-term performance trend analysis and prediction
          - **Regression Detection**: Detect performance regressions and root causes
          - **Capacity Planning**: Predictive capacity planning and resource allocation
          - **Performance Budgets**: Establish and monitor performance budgets
        </performance_monitoring>
      </system_analysis>

      **Optimization Implementation Strategies**:

      <implementation_strategies>
        <architectural_optimization>
          **Architecture-Level Optimizations**:
          1. **Component Architecture**: Optimize component loading and dependency management
          2. **Command Structure**: Streamline command execution paths and reduce overhead
          3. **Data Flow**: Optimize data flow patterns and minimize processing steps
          4. **Integration Patterns**: Improve integration efficiency and reduce coupling
          5. **Scalability Design**: Design for horizontal and vertical scalability
          6. **Performance Patterns**: Implement proven performance patterns and practices
        </architectural_optimization>
        
        <code_optimization>
          **Code-Level Performance Improvements**:
          - **Prompt Optimization**: Refactor prompts for maximum efficiency and clarity
          - **Logic Optimization**: Streamline decision logic and reduce complexity
          - **Data Processing**: Optimize data processing algorithms and structures
          - **Error Handling**: Efficient error handling without performance impact
          - **Validation**: Optimize validation logic for speed and accuracy
          - **Configuration**: Streamline configuration loading and processing
        </code_optimization>
        
        <infrastructure_optimization>
          **Infrastructure Performance Optimization**:
          - **Deployment Optimization**: Optimize deployment patterns for performance
          - **Network Optimization**: Minimize network latency and maximize throughput
          - **Storage Optimization**: Optimize storage access patterns and caching
          - **Load Balancing**: Implement effective load balancing strategies
          - **Auto-Scaling**: Configure intelligent auto-scaling policies
          - **Resource Allocation**: Optimize resource allocation and utilization
        </infrastructure_optimization>
      </implementation_strategies>

      **Advanced Performance Techniques**:

      <advanced_techniques>
        <intelligent_caching>
          **Multi-Level Intelligent Caching**:
          - **Context Caching**: Cache frequently used context and component combinations
          - **Result Caching**: Cache command results for reuse in similar scenarios
          - **Prompt Caching**: Cache optimized prompts to reduce processing overhead
          - **Configuration Caching**: Cache configuration data for fast access
          - **Dependency Caching**: Cache resolved dependencies to avoid recomputation
          - **Adaptive Caching**: Intelligent cache management based on usage patterns
        </intelligent_caching>
        
        <predictive_optimization>
          **Predictive Performance Optimization**:
          - **Usage Prediction**: Predict likely command sequences and pre-optimize
          - **Resource Prediction**: Anticipate resource needs and pre-allocate
          - **Context Prediction**: Predict required context and pre-load efficiently
          - **Performance Prediction**: Predict performance bottlenecks before they occur
          - **Capacity Prediction**: Forecast capacity needs and scale proactively
          - **Optimization Timing**: Optimize timing of optimization activities
        </predictive_optimization>
        
        <adaptive_optimization>
          **Adaptive Performance Management**:
          - **Dynamic Optimization**: Adjust optimization strategies based on runtime conditions
          - **Learning Algorithms**: Learn from usage patterns to improve performance
          - **Self-Tuning**: Automatically tune performance parameters
          - **Adaptive Scaling**: Scale resources based on real-time demand
          - **Performance Adaptation**: Adapt performance strategies to changing conditions
          - **Continuous Improvement**: Continuously improve performance through learning
        </adaptive_optimization>
      </advanced_techniques>

      **Performance Optimization Workflow**:

      <optimization_workflow>
        <analysis_phase>
          **Performance Analysis & Profiling**:
          1. Execute comprehensive performance profiling across all framework components
          2. Identify performance bottlenecks, inefficiencies, and optimization opportunities
          3. Analyze resource utilization patterns and scalability constraints
          4. Benchmark current performance against industry standards
          5. Prioritize optimization efforts based on impact and feasibility
        </analysis_phase>
        
        <optimization_implementation>
          **Performance Optimization Implementation**:
          1. Implement architectural optimizations and design improvements
          2. Execute code-level optimizations and algorithmic improvements
          3. Deploy caching strategies and performance enhancement patterns
          4. Optimize token usage and context management efficiency
          5. Implement monitoring and continuous improvement mechanisms
        </optimization_implementation>
        
        <validation_testing>
          **Optimization Validation & Testing**:
          1. Execute comprehensive performance testing and validation
          2. Verify optimization effectiveness and measure improvements
          3. Test performance under various load conditions and scenarios
          4. Validate that optimizations don't negatively impact functionality
          5. Document performance improvements and optimization results
        </validation_testing>
        
        <continuous_monitoring>
          **Continuous Performance Management**:
          1. Establish ongoing performance monitoring and alerting
          2. Implement continuous optimization and improvement processes
          3. Track performance trends and predict future optimization needs
          4. Maintain performance budgets and quality gates
          5. Plan future optimization initiatives and capacity improvements
        </continuous_monitoring>
      </optimization_workflow>

      **Performance Metrics & KPIs**:

      <performance_metrics>
        <response_metrics>
          **Response Time & Throughput**:
          - **Command Execution Time**: Average and percentile response times
          - **System Throughput**: Commands processed per unit time
          - **Latency Metrics**: End-to-end latency and processing delays
          - **Concurrent Performance**: Performance under concurrent load
          - **Peak Performance**: Performance under peak usage conditions
        </response_metrics>
        
        <resource_metrics>
          **Resource Utilization & Efficiency**:
          - **Memory Usage**: Memory consumption patterns and optimization
          - **Token Utilization**: Token usage efficiency and cost optimization
          - **CPU Efficiency**: Processing efficiency and utilization rates
          - **Cache Performance**: Cache hit rates and effectiveness
          - **Resource Scaling**: Resource scaling efficiency and cost
        </resource_metrics>
        
        <quality_metrics>
          **Quality & Reliability Metrics**:
          - **Error Rates**: Error frequency and impact on performance
          - **Availability**: System uptime and reliability metrics
          - **Consistency**: Performance consistency and predictability
          - **Scalability**: Performance scaling characteristics
          - **User Experience**: Performance impact on user experience
        </quality_metrics>
      </performance_metrics>

      Execute comprehensive performance optimization using Claude's intelligence to identify bottlenecks, implement improvements, and establish continuous performance management. Focus on practical optimizations that deliver measurable performance improvements.

      **Remember**: Performance optimization is an ongoing process. Focus on the highest-impact optimizations first, and establish monitoring to ensure continuous performance improvement and regression prevention.
    </performance_analysis>
  </framework_optimization>

  <o>
Framework performance optimization completed with comprehensive analysis and enhancement:

**Performance Analysis:** [count] framework components analyzed and optimized
**Optimization Level:** [percentage]% performance improvement achieved across components
**Resource Efficiency:** [percentage]% resource utilization optimization completed
**Scalability Enhancement:** [multiplier]x scalability improvement through systematic optimization
**Framework Quality:** [0-100] overall framework performance and efficiency rating
**Enterprise Excellence:** Advanced framework optimization ready for enterprise deployment
  </o>
</prompt_component> 