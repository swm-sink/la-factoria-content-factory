"""
La Factoria - Educational Content Generation Platform
FastAPI Application Template

Generated by /la-factoria-init command
"""

from fastapi import FastAPI, HTTPException, Depends, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
import os
import json
import logging
from datetime import datetime

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize FastAPI app
app = FastAPI(
    title="La Factoria",
    description="Educational Content Generation Platform",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configure appropriately for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Security
security = HTTPBearer()

# Pydantic Models
class HealthResponse(BaseModel):
    status: str
    timestamp: datetime
    version: str
    database_connected: bool

class ContentRequest(BaseModel):
    content_type: str = Field(..., description="Type of content to generate")
    topic: str = Field(..., min_length=3, max_length=500, description="Topic for content generation")
    age_group: Optional[str] = Field("general", description="Target age group")
    additional_requirements: Optional[str] = Field(None, description="Additional requirements")

class ContentResponse(BaseModel):
    id: str
    content_type: str
    topic: str
    generated_content: Dict[str, Any]
    metadata: Dict[str, Any]
    created_at: datetime

class StatsResponse(BaseModel):
    total_content_generated: int
    total_users: int
    uptime_seconds: int
    content_types_counts: Dict[str, int]

# Authentication dependency
async def verify_api_key(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """Verify API key authentication"""
    api_key = os.getenv("LA_FACTORIA_API_KEY")
    if not api_key:
        logger.warning("No API key configured")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="API key not configured"
        )

    if credentials.credentials != api_key:
        logger.warning(f"Invalid API key attempt: {credentials.credentials[:10]}...")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API key"
        )

    return credentials.credentials

# Health Check Endpoint
@app.get("/health", response_model=HealthResponse)
async def health_check():
    """Health check endpoint for monitoring and Railway deployment"""
    # TODO: Add actual database connection check
    database_connected = True  # Placeholder - implement actual DB check

    return HealthResponse(
        status="healthy",
        timestamp=datetime.now(),
        version="1.0.0",
        database_connected=database_connected
    )

# Content Generation Endpoints
@app.post("/api/content/generate", response_model=ContentResponse)
async def generate_content(
    request: ContentRequest,
    api_key: str = Depends(verify_api_key)
):
    """Generate educational content using AI"""
    try:
        logger.info(f"Generating {request.content_type} content for topic: {request.topic}")

        # TODO: Implement actual content generation with AI provider
        # This is a placeholder implementation
        generated_content = {
            "title": f"{request.content_type.title()} for {request.topic}",
            "content": f"This is a placeholder {request.content_type} about {request.topic}",
            "generated_at": datetime.now().isoformat()
        }

        # TODO: Save to database
        content_id = f"content_{datetime.now().timestamp()}"

        return ContentResponse(
            id=content_id,
            content_type=request.content_type,
            topic=request.topic,
            generated_content=generated_content,
            metadata={
                "age_group": request.age_group,
                "requirements": request.additional_requirements,
                "generation_method": "ai_placeholder"
            },
            created_at=datetime.now()
        )

    except Exception as e:
        logger.error(f"Content generation failed: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Content generation failed: {str(e)}"
        )

@app.get("/api/content/types")
async def get_content_types():
    """Get available content types"""
    return {
        "content_types": [
            {
                "id": "master-outline",
                "name": "Master Content Outline",
                "description": "Foundation structure with learning objectives"
            },
            {
                "id": "podcast-script",
                "name": "Podcast Script",
                "description": "Audio content with engagement techniques"
            },
            {
                "id": "study-guide",
                "name": "Study Guide",
                "description": "Comprehensive educational material"
            },
            {
                "id": "one-pager",
                "name": "One-Pager Summary",
                "description": "Concise overview with takeaways"
            },
            {
                "id": "reading-material",
                "name": "Detailed Reading Material",
                "description": "In-depth content with exercises"
            },
            {
                "id": "faq",
                "name": "FAQ Collection",
                "description": "Question-answer pairs"
            },
            {
                "id": "flashcards",
                "name": "Flashcards",
                "description": "Term-definition pairs"
            },
            {
                "id": "reading-questions",
                "name": "Reading Guide Questions",
                "description": "Discussion prompts"
            }
        ]
    }

# User Management (GDPR Compliance)
@app.delete("/api/user/{user_id}")
async def delete_user(
    user_id: str,
    api_key: str = Depends(verify_api_key)
):
    """Delete user and all associated content (GDPR compliance)"""
    try:
        logger.info(f"Deleting user {user_id} and all associated content")

        # TODO: Implement actual user deletion with cascade
        # This is a placeholder implementation
        deleted_content_count = 0  # Placeholder

        return {
            "user_id": user_id,
            "deleted": True,
            "deleted_content_count": deleted_content_count,
            "deleted_at": datetime.now()
        }

    except Exception as e:
        logger.error(f"User deletion failed: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"User deletion failed: {str(e)}"
        )

# Monitoring and Stats
@app.get("/api/stats", response_model=StatsResponse)
async def get_stats(api_key: str = Depends(verify_api_key)):
    """Get basic platform statistics"""
    try:
        # TODO: Implement actual stats from database
        # This is a placeholder implementation
        return StatsResponse(
            total_content_generated=0,
            total_users=0,
            uptime_seconds=3600,  # Placeholder
            content_types_counts={
                "study-guide": 0,
                "flashcards": 0,
                "podcast-script": 0
            }
        )

    except Exception as e:
        logger.error(f"Stats retrieval failed: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Stats retrieval failed: {str(e)}"
        )

# Error Handlers
@app.exception_handler(Exception)
async def global_exception_handler(request, exc):
    """Global exception handler"""
    logger.error(f"Unhandled exception: {str(exc)}")
    return {
        "error": "Internal server error",
        "message": "An unexpected error occurred"
    }

if __name__ == "__main__":
    import uvicorn
    port = int(os.getenv("PORT", 8000))
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=port,
        reload=True if os.getenv("ENVIRONMENT") == "development" else False
    )
